generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                  String                   @id @default(uuid())
  name                String
  email               String                   @unique
  password            String
  bio                 String?
  avatarUrl           String?
  createdAt           DateTime                 @default(now())
  role                Role                     @default(LEARNER)
  timeZone            String?
  receivedConnections Connection[]             @relation("ReceivedConnections")
  sentConnections     Connection[]             @relation("SentConnections")
  following           Follow[]                 @relation("Following")
  followers           Follow[]                 @relation("Followers")
  sessionsAsLearner   Session[]                @relation("LearnerSessions")
  sessionsAsMentor    Session[]                @relation("MentorSessions")
  currentOrganization UserCurrentOrganization?
  currentStatus       UserCurrentStatus?
  experienceSummary   UserExperienceSummary?
  professionDetails   UserProfessionDetails?
  socialLinks         UserSocialLinks?
  skillsOffered       Skill[]                  @relation("SkillsOffered")
  skillsWanted        Skill[]                  @relation("SkillsWanted")

  googleToken        GoogleToken?              @relation("UserGoogleToken")
}

model Skill {
  id        String    @id @default(uuid())
  name      String    @unique
  category  String?
  sessions  Session[] @relation("SkillSessions")
  offeredBy User[]    @relation("SkillsOffered")
  wantedBy  User[]    @relation("SkillsWanted")
}

model Connection {
  id         String           @id @default(uuid())
  senderId   String
  receiverId String
  status     ConnectionStatus @default(PENDING)
  createdAt  DateTime         @default(now())
  receiver   User             @relation("ReceivedConnections", fields: [receiverId], references: [id])
  sender     User             @relation("SentConnections", fields: [senderId], references: [id])
}

model Follow {
  id          String   @id @default(uuid())
  followerId  String
  followingId String
  createdAt   DateTime @default(now())
  follower    User     @relation("Following", fields: [followerId], references: [id])
  following   User     @relation("Followers", fields: [followingId], references: [id])

  @@unique([followerId, followingId])
}

model Session {
  id          String        @id @default(uuid())
  mentorId    String
  learnerId   String
  scheduledAt DateTime
  status      SessionStatus @default(PENDING)
  feedback    String?
  createdAt   DateTime      @default(now())
  skillId     String
  meetLink    String?
  roadmap     Json?  
  learner     User          @relation("LearnerSessions", fields: [learnerId], references: [id])
  mentor      User          @relation("MentorSessions", fields: [mentorId], references: [id])
  skill       Skill         @relation("SkillSessions", fields: [skillId], references: [id])
}

model UserProfessionDetails {
  id     String @id @default(uuid())
  title  String
  userId String @unique
  user   User   @relation(fields: [userId], references: [id])
}

model UserCurrentOrganization {
  id           String @id @default(uuid())
  organization String
  userId       String @unique
  user         User   @relation(fields: [userId], references: [id])
}

model UserExperienceSummary {
  id          String  @id @default(uuid())
  years       Int
  description String?
  userId      String  @unique
  user        User    @relation(fields: [userId], references: [id])
}

model UserCurrentStatus {
  id     String @id @default(uuid())
  status String
  userId String @unique
  user   User   @relation(fields: [userId], references: [id])
}

model UserSocialLinks {
  id       String  @id @default(uuid())
  linkedin String?
  github   String?
  twitter  String?
  leetcode String?
  website  String?
  userId   String  @unique
  user     User    @relation(fields: [userId], references: [id])
}

model GoogleToken {
  id          String   @id @default(uuid())
  accessToken String
  refreshToken String
  scope       String?
  tokenType   String?
  expiryDate  BigInt?
  userId      String   @unique
  user        User     @relation("UserGoogleToken", fields: [userId], references: [id], onDelete: Cascade)
}

enum Role {
  MENTOR
  LEARNER
  BOTH
}

enum ConnectionStatus {
  PENDING
  ACCEPTED
  DECLINED
}

enum SessionStatus {
  PENDING
  CONFIRMED
  COMPLETED
  CANCELLED
  REJECTED
}
